<?php
namespace exface\UI5Facade\Facades\Elements;

use exface\Core\Actions\ReadData;
use exface\Core\Facades\AbstractAjaxFacade\Elements\LeafletTrait;
use exface\Core\Factories\ActionFactory;
use exface\Core\Widgets\Parts\Maps\Interfaces\DataMapLayerInterface;
use exface\UI5Facade\Facades\Elements\Traits\UI5DataElementTrait;
use exface\Core\Widgets\Data;
use exface\UI5Facade\Facades\Interfaces\UI5ControllerInterface;
use exface\Core\DataTypes\StringDataType;
use exface\Core\Widgets\Parts\Maps\DataSelectionMarkerLayer;
use exface\Core\Interfaces\Widgets\iUseData;
use exface\Core\CommonLogic\DataSheets\DataColumn;
use exface\Core\Factories\WidgetFactory;
use exface\Core\Widgets\Parts\Maps\Interfaces\LatLngWidgetLinkMapLayerInterface;

/**
 * 
 * @method exface\Core\Widgets\Chart getWidget()
 * @method UI5ControllerInterface getController()
 * 
 * @author Andrej Kabachnik
 *
 */
class UI5Map extends UI5AbstractElement
{
    use LeafletTrait, UI5DataElementTrait {
        LeafletTrait::buildJsValueGetter insteadof UI5DataElementTrait;
        LeafletTrait::buildJsDataGetter insteadof UI5DataElementTrait;
        UI5DataElementTrait::buildJsGetRowsSelected insteadof LeafletTrait;
        UI5DataElementTrait::buildJsDataLoaderParams as buildJsDataLoaderParamsViaTrait;
    }
    
    private $leafletVarTemp = null;
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\UI5Facade\Facades\Elements\UI5AbstractElement::buildJsConstructor()
     */
    public function buildJsConstructorForControl($oControllerJs = 'oController') : string
    {
        $this->initLeaflet();
        $mapWidget = $this->getWidget();
        
        $this->getConfiguratorElement()->registerFiltersWithApplyOnChange($this);
        
        $controller = $this->getController(); 
        $this->registerExternalModules($controller);
        $this->registerLiveReferenceAtLinkedElements();
        $this->getController()->addOnPrefillDataChangedScript($this->buildJsRefresh());
        
        // Add a single data loader controller method for all layers. However, give it an additional
        // parameter oLeafletParams so each layer can override request params if needed. The content
        // of the method will be generated by the UI5DataElementTrait, but at some point it will call
        // `buildJsDataLoaderParams()` where we will place the logic to handle oLeafletParams.
        $controller->addMethod('onLoadData', $this, 'oControlEvent, bKeepPagingPos, oLeafletParams, oLinkParams', $this->buildJsDataLoader());
        
        $leafletVarJs = $controller->buildJsObjectName('leaflet', $this);
        
        // Make sure buildJsLeafletVar() returns oController.xxx to maximize performance
        // because many initialization scripts require the leaflet variable and would
        // otherwise run all the logic to find the component, the controller, etc.
        $this->leafletVarTemp = 'oController.' . $leafletVarJs;
        
        if ($mapWidget->isCenterBoundToAttributes()) {
            $centerLatCol = DataColumn::sanitizeColumnName($mapWidget->getCenterLatitudeAttributeAlias());
            $centerLngCol = DataColumn::sanitizeColumnName($mapWidget->getCenterLongitudeAttributeAlias());
            $controller->addOnPrefillDataChangedScript(<<<JS
                
                setTimeout(function(){
                    var oPrefillData = {$controller->getView()->buildJsViewGetter($this)}.getModel().getData();
                    var lat = oPrefillData['{$centerLatCol}'];
                    var lng = oPrefillData['{$centerLngCol}'];
                    if (! isNaN(lat) && ! isNaN(lng)) {
                        {$this->buildJsLeafletVar($oControllerJs)}.setView([lat, lng]);
                    }
                }, 0);
                
JS);
        }
        
        // **IMPORTANT:** it seems, an outer div with the id of the control is required because
        // otherwise the map is not rendered at all after navigating to a view via routing. The map
        // gets rendered even before the view is shown, but once the view is visible, the leaflet-div
        // is empty while the leaflet-var is initialized, which is very strange.
        // I guess, this has something to do with the so-called "preserved content" of sap.ui.core.HTML 
        // (see for an explanation for possible causes: https://github.com/SAP/openui5/issues/1162).
        $chart = <<<JS

                new sap.ui.core.HTML("{$this->getId()}", {
                    content: "<div id=\"{$this->getId()}\" style=\"height: 100%;\"><div id=\"{$this->getIdLeaflet()}\" class=\"{$this->buildCssElementClass()}\" style=\"height: 100%; min-height: 100px; overflow: hidden;\"></div></div>",
                    afterRendering: function(oEvent) {
                        if (oController.$leafletVarJs === null || oController.$leafletVarJs === undefined || $('#{$this->getIdLeaflet()}').children().length === 0) {  
                            {$this->buildJsLeafletInit()};     
                        } 

                        sap.ui.core.ResizeHandler.register(sap.ui.getCore().byId('{$this->getId()}').getParent(), function(){
                            if (oController.$leafletVarJs) {
                                {$this->buildJsLeafletResize()}
                            }
                        });

                        sap.ui.getCore().byId('{$this->getId()}').getParent().addStyleClass('sapUiNoContentPadding');
                    }
                })

JS;
        // Remove the precalculated var name after init scripts were generated (see above).
        $this->leafletVarTemp = null;
        
        // Add listeners for mouse events and pseudo events
        // IMPORTANT: add common listeners AFTER removing the leafletVarTemp! This is important because
        // otherwise code generated for data getters inside these handlers will include the final
        // leaflet getter and not the temporary one!
        $controller->addOnInitScript(<<<JS
            
                sap.ui.getCore().byId("{$this->getId()}")
                {$this->buildJsClickHandlers($oControllerJs)}
                {$this->buildJsPseudoEventHandlers()}

JS);
        
        foreach ($this->getWidget()->getLayers() as $layer) {
            if ($layer instanceof LatLngWidgetLinkMapLayerInterface) {
                if (($linkLat = $layer->getLatitudeWidgetLink()) && ($linkLng = $layer->getLongitudeWidgetLink())) {
                    $this->getFacade()->getElement($linkLat->getTargetWidget())->addOnChangeScript($this->buildJsRefresh());
                    $this->getFacade()->getElement($linkLng->getTargetWidget())->addOnChangeScript($this->buildJsRefresh());
                }
            }
        }
                        
        return $this->buildJsPanelWrapper($chart, $oControllerJs);
    }
    
    /**
     * When the data loader calls buildJsDataLoaderParams() we need to extend
     * the default request parameters with those passed to the onLoadData...() method
     * by the respective layer and widgets possibly linked there. This is done here.
     * 
     * @see UI5DataElementTrait::buildJsDataLoaderParams()
     */
    protected function buildJsDataLoaderParams(string $oControlEventJsVar = 'oControlEvent', string $oParamsJs = 'params', $keepPagePosJsVar = 'bKeepPagingPos') : string
    {
        return $this->buildJsDataLoaderParamsViaTrait($oControlEventJsVar, $oParamsJs, $keepPagePosJsVar) . <<<JS
            // TODO check for the same object before extending anything here
            $oParamsJs = (function(oMapParams, oLeafletParams, oLinkParams){
                var oMergedParams = $.extend({}, oLeafletParams);
                oMergedParams.data.filters = oLinkParams.data.filters;
                return oMergedParams;
            })($oParamsJs, oLeafletParams, oLinkParams);
JS;
    }

    /**
     * Checks if another data loader request is pending - and if it is the same data or different
     * 
     * In contrast to simpler data widgets, maps can load data of different layers. These requests should not
     * block or enqueue each other because they are all needed. Thus, the pending mechanism below is modified
     * to split pending data by layer index.
     * 
     * @see UI5DataElementTrait::buildJsDataLoaderCheckPendingData()
     * 
     * @param string $oCtrlJs
     * @param string $oRequestParamsJs
     * @return string
     */
    public function buildJsDataLoaderCheckPendingData(string $oCtrlJs, string $oRequestParamsJs) : string
    {
        return <<<JS

                (function(oTable, oParams){
                    // Current hash - it exists here and in the returned callback
                    var sCurrentRequestData = JSON.stringify(oParams.data);
                    var iLayerIdx = oParams._layer;
                    if (oTable._exfPendingData === undefined) {
                        oTable._exfPendingData = {};
                    }
    
                    if (oTable._exfPendingData[iLayerIdx] !== undefined) {
                        // Skip server request if still waiting for a response
                        if (oTable._exfPendingData[iLayerIdx] !== sCurrentRequestData) {
                            // Update pending data if current request has other data to make sure
                            // an auto-refresh is done afterwards to show latest information
                            oTable._exfPendingData[iLayerIdx] = sCurrentRequestData;
                        }
                        return true;
                    } else {
                        // Remember current data to make it possible to skip concurrent requests
                        // via the above if()
                        oTable._exfPendingData[iLayerIdx] = sCurrentRequestData;
                    }
                    return function() {
                        if (oTable._exfPendingData[iLayerIdx] !== undefined && oTable._exfPendingData[iLayerIdx] !== sCurrentRequestData) {
                            delete oTable._exfPendingData[iLayerIdx];
                            return true;
                        } else {
                            delete oTable._exfPendingData[iLayerIdx];
                        }
                    };
                })($oCtrlJs, $oRequestParamsJs)
JS;
    }

    /**
     * When a Leaflet layer loads data, call the regular UI5 data loader, but do some post-processing
     * 
     * In `buildJsConstrcutorForControl` we give the `onLoadData` controller method an additional
     * parameter oLeafletParams so each layer can override request params if needed. The content
     * of the method will be generated by the UI5DataElementTrait, but at some point it will call
     * `buildJsDataLoaderParams()` where we will place the logic to handle oLeafletParams.
     * 
     * @param DataMapLayerInterface $layer
     * @param string $oLeafletParamsJs
     * @param string $aResultRowsJs
     * @param string $onLoadedJs
     * @return string
     */
    protected function buildJsLeafletDataLoader(DataMapLayerInterface $layer, string $oLeafletParamsJs, string $aResultRowsJs, string $onLoadedJs) : string
    {
        $layerDataWidget = $layer->getDataWidget();
        $mapWidget = $this->getWidget();
        
        // If the layer is based on a different object than the map, make sure the input data of the action
        // is provided the configurator of the layer and not the configurator of the map.
        if (! $layerDataWidget->getMetaObject()->is($mapWidget->getMetaObject())) {
            $layerConfiguratorWidget = $layerDataWidget->getConfiguratorWidget();
            $layerConfiguratorEl = $this->getFacade()->getElement($layerConfiguratorWidget);
            // Replace action input data with data from the layer configurator (which is not rendered, so use
            // the unrendered mode of buildJsDataGetter() for configurators)
            $unrendered = $layerDataWidget->isConfiguratorLinked() ? false : true;
            $readAction = ActionFactory::createFromString($this->getWorkbench(), ReadData::class, $layerDataWidget);
            $oLinkParamsJs = "{data: {$layerConfiguratorEl->buildJsDataGetter($readAction, $unrendered)}}";
        } else {
            $oLinkParamsJs = "{}";
        }
        
        return <<<JS

        {$this->getController()->buildJsMethodCallFromController('onLoadData', $this, "null, null, $oLeafletParamsJs, $oLinkParamsJs")}
        .then(function(oModel) {
            var $aResultRowsJs = oModel.getData().rows || [];
            $onLoadedJs
        })
JS;
    }
    
    public function getIdLeaflet() : string
    {
        return $this->getId() . '_leaflet';
    }

    /**
     * {@inheritDoc}
     * @see LeafletTrait::buildJsLeafletVar()
     */
    public function buildJsLeafletVar(string $oControllerJs = null) : string
    {
        if ($this->leafletVarTemp !== null) {
            return $this->leafletVarTemp;
        }
        $controller = $this->getController();
        if (! $controller->hasDependent('leaflet', $this)) {
            $controller->addProperty($controller->buildJsObjectName('leaflet', $this), 'null');
        }
        return $controller->buildJsDependentObjectGetter('leaflet', $this, $oControllerJs);
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\UI5Facade\Facades\Elements\UI5AbstractElement::registerExternalModules()
     */
    public function registerExternalModules(UI5ControllerInterface $controller) : UI5AbstractElement
    {
        $f = $this->getFacade();
        $mainSrc = $f->buildUrlToSource('LIBS.LEAFLET.JS');
        $controller->addExternalModule('libs.exface.leaflet', $mainSrc, null, 'L');
        
        foreach ($this->getJsIncludes() as $src) {
            if ($src === $mainSrc) {
                continue;
            }
            
            $name = StringDataType::substringAfter($src, '/', $src, false, true);
            $name = str_replace('-', '_', $name);
            
            $name = 'libs.exface.leaflet.' . $name;
            $controller->addExternalModule($name, $src);
        }
        
        foreach ($this->getCssIncludes() as $src) {
            $controller->addExternalCss($src);
        }
        
        foreach ($this->getWidget()->getDataLayers() as $layer) {
            foreach ($layer->getDataWidget()->getColumns() as $col) {
                $f->getElement($col)->registerExternalModules($controller);
            }
        }
        return $this;
    }
        
    /**
     * 
     * @return array
     */
    protected function getJsIncludes() : array
    {
        $htmlTagsArray = $this->buildHtmlHeadTagsLeaflet();
        $tags = implode('', $htmlTagsArray);
        $jsTags = [];
        preg_match_all('#<script[^>]*src="([^"]*)"[^>]*></script>#is', $tags, $jsTags);
        return $jsTags[1];
    }
    
    /**
     *
     * @return array
     */
    protected function getCssIncludes() : array
    {
        $htmlTagsArray = $this->buildHtmlHeadTagsLeaflet();
        $tags = implode('', $htmlTagsArray);
        $jsTags = [];
        preg_match_all('#<link[^>]*href="([^"]*)"[^>]*/?>#is', $tags, $jsTags);
        return $jsTags[1];
    }
        
    /**
     *
     * {@inheritDoc}
     * @see exface\Core\Facades\AbstractAjaxFacade\Elements\LeafletTrait::buildJsRefresh()
     */
    public function buildJsRefresh(bool $keepPagingPosition = false) : string
    {
        return "if ({$this->buildJsLeafletVar()} !== null) { {$this->buildJsLeafletRefresh()} }";
    }
    
    /**
     * Returns the main data widget of the map - either the data of the first layer based on the same object
     * as the map itself or an empty "fake" data widget.
     * 
     * @see UI5DataElementTrait
     */
    protected function getDataWidget() : Data
    {
        foreach ($this->getWidget()->getDataLayers() as $layer) {
            if (($layer instanceof DataMapLayerInterface) && $layer->getMetaObject()->is($this->getMetaObject())) {
                return $layer->getDataWidget();
            }
        }
        return WidgetFactory::create($this->getWidget()->getPage(), 'Data', $this->getWidget());
    }
    
    /**
     * {@inheritdoc}
     * @see \exface\UI5Facade\Facades\Elements\Traits\UI5DataElementTrait::buildJsShowMessageOverlay()
     */
    protected function buildJsShowMessageOverlay(string $message) : string
    {
        return '';
    }
    
    /**
     *
     * {@inheritdoc}
     * @see UI5DataElementTrait::buildJsOfflineHint()
     */
    protected function buildJsOfflineHint(string $oTableJs = 'oTable') : string
    {
        return '';
    }
    
    /**
     * 
     * @see UI5DataElementTrait::isEditable()
     */
    protected function isEditable()
    {
        return false;
    }
    
    /**
     * 
     * @see UI5DataElementTrait::buildJsGetRowsSelected()
     */
    protected function buildJsGetRowsSelected(string $oControlJs) : string
    {
        return $this->buildJsLeafletGetSelectedRows();
    }
    
    /**
     * @see UI5DataElementTrait
     */
    protected function hasPaginator() : bool
    {
        return false;
    }
    
    /**
     * @see UI5DataElementTrait
     */
    protected function hasQuickSearch() : bool
    {
        return false;
    }

    public function buildJsBusyIconShow($global = false) {
        $showLoading = $this->getWidget()->getShowLoadingIndicator();
        if (!$showLoading) {
            return '';
        } else  {
            return parent::buildJsBusyIconShow($global);
        }
    }
    
    /**
     *
     * @see LeafletTrait::registerLiveReferenceAtLinkedElements()
     */
    protected function registerLiveReferenceAtLinkedElements()
    {
        foreach ($this->getWidget()->getLayers() as $layer) {
            // Need to update the map in sync with a linked widget if we have a data_widget_link or a data
            // definition with a configurator_widget_link
            if (($layer instanceof iUseData)) {
                $link = $layer->getDataWidgetLink() ?? $layer->getData()->getConfiguratorWidgetLink();
                if ($link) {
                    $linked_element = $this->getFacade()->getElement($link->getTargetWidget());
                    if ($linked_element) {
                        if ($layer instanceof DataSelectionMarkerLayer) {
                            $linked_element->addOnSelectScript($this->buildJsLeafletRefresh($layer, 'linked_selection_changed'));
                        } else {
                            $linked_element->addOnRefreshScript("setTimeout(function(){ {$this->buildJsLeafletRefresh($layer, 'linked_data_changed')} }, 100);");
                        }
                    }
                }
            }
        }
        return $this;
    }
    
    /**
     *
     * @see UI5DataElementTrait::isWrappedInPanel()
     */
    protected function isWrappedInPanel() : bool
    {
        return true;
    }
}